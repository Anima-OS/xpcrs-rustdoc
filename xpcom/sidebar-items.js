initSidebarItems({"fn":[["component_manager","Get a reference to the global `nsIComponentManager`."],["component_registrar","Get a reference to the global `nsIComponentRegistrar`"],["create_instance","Helper for calling `nsIComponentManager::CreateInstanceByContractID` on the global `nsIComponentRegistrar`."],["get_service","Helper for calling `nsIServiceManager::GetServiceByContractID` on the global `nsIServiceManager`."],["getter_addrefs","Helper method for calling XPCOM methods which return a reference counted value through an outparameter. Takes a lambda, which is called with a valid outparameter argument (`*mut *const T`), and returns a `nsresult`. Returns either a `RefPtr<T>` with the value returned from the outparameter, or a `nsresult`."],["service_manager","Get a reference to the global `nsIServiceManager`."]],"mod":[["interfaces","This module contains the xpcom interfaces exposed to rust code."],["services","This module contains convenient accessors for XPCOM services."]],"struct":[["AtomicRefcnt","The type of the atomic reference count used for xpcom structs."],["GetterAddrefs","A helper struct for constructing `RefPtr<T>` from raw pointer outparameters. Holds a `*const T` internally which will be released if non null when destructed, and can be easily transformed into an `Option<RefPtr<T>>`."],["RefPtr","A smart pointer holding a RefCounted object. The object itself manages its own memory. RefPtr will invoke the addref and release methods at the appropriate times to facilitate the bookkeeping."],["Refcnt","The type of the reference count type for xpcom structs."],["nsID","A \"unique identifier\". This is modeled after OSF DCE UUIDs."]],"trait":[["RefCounted","A trait representing a type which can be reference counted invasively. The object is responsible for freeing its backing memory when its reference count reaches 0."],["XpCom","A type which implements XpCom must follow the following rules:"]],"type":[["nsCID","Class IDs"],["nsIID","Interface IDs"]]});